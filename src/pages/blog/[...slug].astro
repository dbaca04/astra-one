---
import {
    getCollection,
    getEntry,
    render,
    type CollectionEntry,
} from "astro:content";
import BlogPost from "../../layouts/BlogPost.astro";
import PostNavigation from "../../components/PostNavigation.astro";
import {
    getAdjacentPosts,
    getAdjacentPostsInSection,
} from "../../utils/blogNavigation";

// This function is required for Astro to know which paths to generate
export async function getStaticPaths() {
    const allblog = await getCollection("blog");
    return allblog.map((post) => ({
        params: { slug: post.id },
        props: { entryId: post.id },
    }));
}

// Get the entryId from the props
const { entryId } = Astro.props;

// Fetch the full entry using getEntry
const post = await getEntry("blog", entryId);

// Handle case where entry is not found (shouldn't happen with getStaticPaths, but good practice)
if (!post) {
    // You might want to render a 404 page here
    // Astro.redirect('/404'); // Example redirect (requires SSR or a client-side approach)
    throw new Error(`Blog post with id ${entryId} not found.`);
}

// Get the previous and next posts chronologically
const { prev: prevPost, next: nextPost } = await getAdjacentPosts(entryId);

// Type-safe access to section
type BlogData = CollectionEntry<"blog">["data"];
type BlogDataWithSection = BlogData & { section?: string };
const postData = post.data as BlogDataWithSection;

// Get the previous and next posts within the same section if section is defined
const { prev: prevSectionPost, next: nextSectionPost } = postData.section
    ? await getAdjacentPostsInSection(entryId)
    : { prev: undefined, next: undefined };

// Determine if we have section-specific navigation
const hasSectionNav = Boolean(
    postData.section && (prevSectionPost || nextSectionPost),
);

const { Content } = await render(post);
---

<BlogPost {...post.data}>
    <Content />

    {/* Add navigation after the content */}
    {
        (prevPost || nextPost || prevSectionPost || nextSectionPost) && (
            <div class="post-navigation-container">
                {hasSectionNav && (
                    <div class="navigation-section">
                        <PostNavigation
                            prevPost={prevSectionPost}
                            nextPost={nextSectionPost}
                            isSectionNav={true}
                            title={`Navigate within ${postData.section}`}
                        />
                    </div>
                )}

                {(prevPost || nextPost) && (
                    <div class="navigation-section">
                        <PostNavigation
                            prevPost={prevPost}
                            nextPost={nextPost}
                            title="Chronological Navigation"
                        />
                    </div>
                )}
            </div>
        )
    }
</BlogPost>

<style>
    .post-navigation-container {
        margin-top: 4rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    /* If there's only one navigation section, add some bottom margin */
    .navigation-section:only-child {
        margin-bottom: 1rem;
    }

    /* On mobile devices, reduce the top margin and gap */
    @media (max-width: 768px) {
        .post-navigation-container {
            margin-top: 3rem;
            gap: 1.5rem;
        }
    }

    @media (max-width: 480px) {
        .post-navigation-container {
            margin-top: 2.5rem;
            gap: 1.25rem;
        }
    }
</style>
