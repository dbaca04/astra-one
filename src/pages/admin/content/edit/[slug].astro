---
import AdminLayout from "../../../../layouts/AdminLayout.astro";
import { getEntry, type CollectionEntry } from "astro:content";
import fs from "node:fs/promises";
import path from "node:path";
import yaml from "js-yaml";
import matter from "gray-matter";
import { marked } from "marked";
import DOMPurify from "dompurify";

// Authentication Check
const sessionCookie = Astro.cookies.get("session");
if (!sessionCookie || sessionCookie.value !== "admin") {
    return Astro.redirect("/admin/login", 302);
}

export const prerender = false;

const { slug: urlSlugParam } = Astro.params; // urlSlugParam can be undefined
const urlSlug = urlSlugParam ?? null; // Now urlSlug is string | null

const contentType = Astro.url.searchParams.get("type") || "draft";

let frontmatter: Record<string, any> = {};
let body = "";
let error: string | null = null;
let actualFileSlugForSaving: string | null = urlSlug;
let isPublishedContent = contentType === "published";

if (urlSlug) {
    if (isPublishedContent) {
        try {
            const postEntry = await getEntry("blog", urlSlug);
            if (postEntry) {
                frontmatter = postEntry.data as Record<string, any>;
                const blogContentDir = path.join(
                    process.cwd(),
                    "src/content/blog",
                );
                let foundFilePath: string | null = null; // Explicitly typed
                const possibleExtensions = [".md", ".mdx"];
                for (const ext of possibleExtensions) {
                    const testPath = path.join(
                        blogContentDir,
                        `${urlSlug}${ext}`,
                    );
                    try {
                        await fs.access(testPath);
                        foundFilePath = testPath;
                        break;
                    } catch {
                        // File not found
                    }
                }

                if (foundFilePath) {
                    const rawFileContent = await fs.readFile(
                        foundFilePath,
                        "utf-8",
                    );
                    const parsedFile = matter(rawFileContent);
                    frontmatter = parsedFile.data || {};
                    body = parsedFile.content.trim();
                } else {
                    error = `Published post file for slug '${urlSlug}' not found in src/content/blog/.`;
                    Astro.response.status = 404;
                }
            } else {
                error = `Published post with slug '${urlSlug}' not found.`;
                Astro.response.status = 404;
            }
        } catch (e: any) {
            console.error(`Error fetching published post '${urlSlug}':`, e);
            error = `Error loading published post: ${e.message}`;
            Astro.response.status = 500;
        }
    } else {
        const draftsDir = path.join(process.cwd(), "src/content/drafts");
        let matchedFileContent: {
            fm: Record<string, any>;
            contentBody: string;
            filenameSlug: string;
        } | null = null;

        try {
            const filesInDrafts = await fs.readdir(draftsDir);
            let primaryMatch: any = null;
            let fallbackMatch: any = null;

            for (const filenameInDir of filesInDrafts) {
                if (
                    !filenameInDir.endsWith(".md") &&
                    !filenameInDir.endsWith(".mdx")
                ) {
                    continue;
                }
                const currentFilePath = path.join(draftsDir, filenameInDir);
                let rawFileContent = await fs
                    .readFile(currentFilePath, "utf-8")
                    .catch(() => "");
                if (!rawFileContent) continue;

                const parsedFile = matter(rawFileContent);
                const currentFileFM = parsedFile.data || {};
                const currentFileBody = parsedFile.content.trim();
                const currentFilenameSlug = filenameInDir.replace(
                    /\.(md|mdx)$/,
                    "",
                );

                if (currentFileFM.slug && currentFileFM.slug === urlSlug) {
                    primaryMatch = {
                        fm: currentFileFM,
                        contentBody: currentFileBody,
                        filenameSlug: currentFilenameSlug,
                    };
                    break;
                }
                if (
                    currentFilenameSlug === urlSlug &&
                    (!currentFileFM.slug ||
                        currentFileFM.slug === currentFilenameSlug) &&
                    !fallbackMatch
                ) {
                    fallbackMatch = {
                        fm: currentFileFM,
                        contentBody: currentFileBody,
                        filenameSlug: currentFilenameSlug,
                    };
                }
            }

            matchedFileContent = primaryMatch || fallbackMatch;

            if (matchedFileContent) {
                frontmatter = matchedFileContent.fm;
                body = matchedFileContent.contentBody;
                actualFileSlugForSaving = matchedFileContent.filenameSlug;
            } else {
                error = `Draft matching URL slug '${urlSlug}' not found.`;
                Astro.response.status = 404;
            }
        } catch (dirError: any) {
            error = `Server error accessing drafts: ${dirError.message}`;
            Astro.response.status = 500;
        }
    }
} else {
    error = "No slug provided.";
    Astro.response.status = 400;
}

console.log(
    `Editing page for URL slug: ${urlSlug}, Content Type: ${contentType}, Resolved slug for saving: ${actualFileSlugForSaving}, Is Published: ${isPublishedContent}`,
);

let clientVarsFrontmatter: Record<string, string | boolean | number | null> =
    {};
if (frontmatter && typeof frontmatter === "object") {
    for (const [key, value] of Object.entries(frontmatter)) {
        if (value instanceof Date) {
            clientVarsFrontmatter[key] = value.toISOString();
        } else {
            clientVarsFrontmatter[key] = value;
        }
    }
}
---

<AdminLayout
    title={`Edit ${isPublishedContent ? "Published Post" : "Draft"}: ${urlSlug ?? "New"}`}
>
    <!-- Add CDN links for marked, DOMPurify, and Mermaid -->
    <script is:inline src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
    ></script>
    <script
        is:inline
        src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"
    ></script>
    <script
        is:inline
        src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"
    ></script>

    <div class="container px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">
            Edit {isPublishedContent ? "Published Post" : "Draft"}: {
                urlSlug ?? "New"
            }
        </h1>
        {
            error && (
                <div
                    class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4"
                    role="alert"
                >
                    <strong class="font-bold">Error!</strong>
                    <span class="block sm:inline"> {error}</span>
                </div>
            )
        }
        {
            !error && actualFileSlugForSaving && (
                <form
                    id="editForm"
                    class="bg-theme-card-bg p-6 rounded-lg shadow-md"
                >
                    <input type="file" id="imageUploadInput" class="hidden" accept="image/*">
                    <h2 class="text-2xl font-semibold mb-4">Frontmatter</h2>
                    {Object.entries(frontmatter).map(([key, value]) => (
                        <div class="mb-4">
                            <label
                                for={key}
                                class="block text-sm font-medium text-theme-text capitalize"
                            >
                                {key.replace(/([A-Z])/g, " $1")}
                            </label>
                            {key === "draft" && isPublishedContent ? (
                                <>
                                    <input
                                        type="checkbox"
                                        id={key}
                                        name={key}
                                        checked={Boolean(value)}
                                        disabled
                                        class="mt-1 h-5 w-5 text-theme-accent border-theme-border rounded focus:ring-theme-accent disabled:opacity-50"
                                    />
                                    <p class="text-xs text-theme-text-muted mt-1">
                                        The 'draft' status of a published post
                                        is managed via publish/unpublish
                                        actions.
                                    </p>
                                </>
                            ) : typeof value === "boolean" ? (
                                <input
                                    type="checkbox"
                                    id={key}
                                    name={key}
                                    checked={Boolean(value)}
                                    class="mt-1 h-5 w-5 text-theme-accent border-theme-border rounded focus:ring-theme-accent"
                                />
                            ) : typeof value === "number" ? (
                                <input
                                    type="number"
                                    id={key}
                                    name={key}
                                    value={value}
                                    class="mt-1 block w-full px-3 py-2 border border-theme-border rounded-md shadow-sm bg-theme-bg focus:ring-theme-accent focus:border-theme-accent"
                                />
                            ) : (
                                <input
                                    type="text"
                                    id={key}
                                    name={key}
                                    value={
                                        key === "tags" && Array.isArray(value)
                                            ? value.join(", ")
                                            : String(value ?? "")
                                    }
                                    class="mt-1 block w-full px-3 py-2 border border-theme-border rounded-md shadow-sm bg-theme-bg focus:ring-theme-accent focus:border-theme-accent"
                                />
                            )}
                        </div>
                    ))}
                    <div id="content-body-section" class="mb-8">
                        <h2 class="text-2xl font-semibold mb-4">Content Body</h2>

                        <!-- Markdown Editor Toolbar -->
                        <div id="markdown-toolbar" class="mb-2 flex items-center space-x-2 p-2 border border-theme-border rounded-md bg-theme-bg-alt">
                            <button type="button" id="toolbar-bold" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Bold">B</button>
                            <button type="button" id="toolbar-italic" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Italic">I</button>
                            <button type="button" id="toolbar-h1" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Heading 1">H1</button>
                            <button type="button" id="toolbar-h2" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Heading 2">H2</button>
                            <button type="button" id="toolbar-h3" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Heading 3">H3</button>
                            <button type="button" id="toolbar-ul" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Unordered List">UL</button>
                            <button type="button" id="toolbar-ol" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Ordered List">OL</button>
                            <button type="button" id="toolbar-link" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Link">Link</button>
                            <button type="button" id="toolbar-image" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Image">Image</button>
                            <button type="button" id="toolbar-codeblock" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Code Block">Code</button>
                            <button type="button" id="toolbar-blockquote" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Blockquote">Quote</button>
                            <button type="button" id="toolbar-help" class="px-2 py-1 border border-theme-border rounded hover:bg-theme-bg text-theme-text" title="Markdown Help">Help</button>
                            <!-- More buttons will be added in subsequent tasks -->
                        </div>

                        <div
                            id="split-screen-editor-container"
                            class="mb-6 flex flex-col md:flex-row md:space-x-4"
                        >
                            {/* Left Pane: Markdown Editor */}
                            <div class="md:w-1/2 w-full mb-4 md:mb-0">
                                <label
                                    for="body"
                                    class="block text-sm font-medium text-theme-text mb-1"
                                >
                                    Markdown Input
                                </label>
                                <textarea
                                    id="body"
                                    name="body"
                                    rows="25"
                                    class="mt-1 block w-full h-full px-3 py-2 border border-theme-border rounded-md shadow-sm bg-theme-bg focus:ring-theme-accent focus:border-theme-accent resize-none"
                                    set:text={body}
                                >
                                </textarea>
                            </div>
                            {/* Right Pane: HTML Preview */}
                            <div class="md:w-1/2 w-full">
                                <label
                                    for="preview"
                                    class="block text-sm font-medium text-theme-text mb-1"
                                >
                                    Live Preview
                                </label>
                                <div
                                    id="preview"
                                    class="mt-1 block w-full h-full px-3 py-2 border border-theme-border rounded-md shadow-sm bg-theme-bg overflow-y-auto prose dark:prose-invert max-w-none"
                                    style="min-height: 500px;"
                                >
                                    {/* Preview content will be injected here by JavaScript */}
                                </div>
                            </div>
                        </div>

                        <!-- Image List Area -->
                        <div id="imageListArea" class="mt-6 p-4 border border-theme-border rounded-lg bg-theme-card-bg shadow-md hidden">
                            <h3 class="text-xl font-semibold mb-2">Images in Content:</h3>
                            <ul id="imageList"></ul>
                        </div>

                    </div>
                    <div class="flex items-center justify-between mt-6">
                        <button
                            type="submit"
                            id="saveButton"
                            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                        >
                            Save Changes
                        </button>
                        <button
                            type="button"
                            id="aiSuggestButton"
                            class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                        >
                            Get AI Suggestions
                        </button>
                    </div>
                </form>
            )
        }
        <div
            id="aiSuggestionsArea"
            class="mt-6 p-4 border border-theme-border rounded-lg bg-theme-card-bg shadow-md hidden"
        >
            <h3 class="text-xl font-semibold mb-2">AI Suggestions:</h3>
            <p id="aiSuggestionsText" class="text-theme-text-muted"></p>
        </div>
        <p class="mt-4">Raw URL slug: <code>{urlSlug ?? "N/A"}</code></p>
        {
            actualFileSlugForSaving && (
                <p class="mt-1">
                    Effective slug for saving:{" "}
                    <code>{actualFileSlugForSaving}</code> ({contentType})
                </p>
            )
        }
        <div id="feedbackMessage" class="mt-4"></div>
    </div>
</AdminLayout>

<script
    define:vars={{
        slugToSave: actualFileSlugForSaving ?? "",
        contentType: contentType,
        initialFrontmatter: clientVarsFrontmatter,
    }}
>
    const form = document.getElementById("editForm");
    const saveButton = document.getElementById("saveButton");
    const feedbackMessage = document.getElementById("feedbackMessage");
    const aiSuggestButton = document.getElementById("aiSuggestButton");
    const aiSuggestionsArea = document.getElementById("aiSuggestionsArea");
    const aiSuggestionsText = document.getElementById("aiSuggestionsText");
    const markdownInput = document.getElementById("body"); // Markdown textarea
    const htmlPreview = document.getElementById("preview"); // Preview div
    const imageListArea = document.getElementById("imageListArea"); // Image List Area
    const imageList = document.getElementById("imageList"); // Image List UL
    const imageUploadInput = document.getElementById("imageUploadInput"); // Hidden file input

    // Toolbar buttons
    const toolbarBold = document.getElementById("toolbar-bold");
    const toolbarItalic = document.getElementById("toolbar-italic");
    const toolbarH1 = document.getElementById("toolbar-h1");
    const toolbarH2 = document.getElementById("toolbar-h2");
    const toolbarH3 = document.getElementById("toolbar-h3");
    const toolbarUL = document.getElementById("toolbar-ul");
    const toolbarOL = document.getElementById("toolbar-ol");
    const toolbarLink = document.getElementById("toolbar-link");
    const toolbarImage = document.getElementById("toolbar-image");
    const toolbarCodeBlock = document.getElementById("toolbar-codeblock");
    const toolbarBlockquote = document.getElementById("toolbar-blockquote");
    const toolbarHelp = document.getElementById("toolbar-help");

    // Debounce function
    function debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }

    // Function to update preview
    async function updatePreview() {
        console.log("updatePreview called");

        if (typeof marked === "undefined") {
            console.error("marked library is not loaded!");
            if (htmlPreview instanceof HTMLElement)
                htmlPreview.textContent =
                    "Error: Markdown library (marked) not loaded.";
            return;
        }
        if (typeof DOMPurify === "undefined") {
            console.error("DOMPurify library is not loaded!");
            if (htmlPreview instanceof HTMLElement)
                htmlPreview.textContent =
                    "Error: Sanitizer library (DOMPurify) not loaded.";
            return;
        }
        if (typeof mermaid === "undefined" || typeof mermaid.initialize !== "function") {
            console.error("mermaid library is not loaded or initialized!");
            if (htmlPreview instanceof HTMLElement)
                htmlPreview.textContent = "Error: Diagram library (mermaid) not loaded.";
            return;
        }

        if (
            markdownInput instanceof HTMLTextAreaElement &&
            htmlPreview instanceof HTMLElement
        ) {
            const markdownText = markdownInput.value;
            console.log("Markdown text length:", markdownText.length);
            try {
                const parseResult = marked.parse(markdownText);
                console.log("marked.parse result type:", typeof parseResult);

                const processHtml = async (htmlContent) => {
                    console.log(
                        "processHtml called with type:",
                        typeof htmlContent,
                    );
                    if (typeof htmlContent === "string") {
                        try {
                            // Sanitize the HTML first
                            const sanitizedHtml = DOMPurify.sanitize(htmlContent);

                            // Create a temporary div to process Mermaid
                            const tempDiv = document.createElement("div");
                            tempDiv.innerHTML = sanitizedHtml;

                            // Find Mermaid elements within the temporary div
                            const mermaidElements = tempDiv.querySelectorAll(
                                "code.language-mermaid, pre.mermaid"
                            );

                            if (mermaidElements.length > 0) {
                                console.log(
                                    `Found ${mermaidElements.length} mermaid elements.`
                                );
                                // Temporarily append to body to allow mermaid to calculate dimensions correctly
                                // Or investigate if mermaid.run can work on detached elements reliably with config
                                // For now, append, run, then detach and use innerHTML
                                document.body.appendChild(tempDiv);
                                try {
                                    await mermaid.run({ nodes: mermaidElements });
                                    console.log("Mermaid run complete.");
                                } catch (mermaidError) {
                                    console.error("Error running Mermaid:", mermaidError);
                                    // Optionally display a placeholder or error in the preview
                                } finally {
                                    document.body.removeChild(tempDiv);
                                }

                                // Get the HTML from the temporary div after Mermaid processing
                                htmlPreview.innerHTML = tempDiv.innerHTML;
                                console.log("Preview updated with Mermaid processed HTML.");
                            } else {
                                // No mermaid elements, just set the sanitized HTML
                                htmlPreview.innerHTML = sanitizedHtml;
                                console.log("Preview updated with sanitized HTML.");
                            }
                        } catch (sanitizeError) {
                            console.error(
                                "Error during DOMPurify.sanitize or Mermaid processing:",
                                sanitizeError,
                            );
                            htmlPreview.textContent = "Error: Preview sanitization or diagram rendering failed.";
                        }
                    } else {
                        console.error(
                            "Processed HTML content is not a string:",
                            htmlContent,
                        );
                        htmlPreview.textContent =
                            "Error: Preview could not be generated (invalid HTML content type).";
                    }
                };

                if (parseResult && typeof parseResult.then === "function") {
                    console.log(
                        "Handling async marked.parse result (Promise).",
                    );
                    // Handle if marked.parse returns a Promise (async usage)
                    parseResult
                        .then((html) => {
                            console.log("Async marked.parse resolved.");
                            processHtml(html);
                        })
                        .catch((err) => {
                            console.error("Error in async marked.parse:", err);
                            htmlPreview.textContent =
                                "Error: Markdown parsing failed (async).";
                        });
                } else {
                    console.log(
                        "Handling sync marked.parse result (string or other).",
                    );
                    // Handle if marked.parse returns a string directly (sync usage)
                    processHtml(parseResult);
                }
            } catch (e) {
                console.error("Error during markdown parsing or sanitization:", e);
                if (htmlPreview instanceof HTMLElement)
                    htmlPreview.textContent = "Error: Preview generation failed.";
            }
        }
    }

    // Debounced preview update
    const debouncedUpdatePreview = debounce(updatePreview, 300);

    // Event listener for markdown input
    if (markdownInput) {
        mermaid.initialize({ startOnLoad: false }); // Initialize Mermaid once
        markdownInput.addEventListener("input", () => {
            console.log("Markdown input event fired.");
            debouncedUpdatePreview();
        });
        // Initial preview on page load
        updatePreview();
    }

    // Helper function to apply markdown formatting
    function applyMarkdownFormatting(prefix, suffix, placeholder = "text") {
        if (!(markdownInput instanceof HTMLTextAreaElement)) return;

        const start = markdownInput.selectionStart;
        const end = markdownInput.selectionEnd;
        const value = markdownInput.value;

        const textBeforeSelection = value.substring(0, start);
        const textAfterSelection = value.substring(end);
        const originalSelectedText = value.substring(start, end);

        if (originalSelectedText && originalSelectedText.trim() !== "") {
            // Selection exists and is not just whitespace
            const coreText = originalSelectedText.trim();
            const leadingSpaceInSelection = originalSelectedText.substring(0, originalSelectedText.indexOf(coreText));
            const trailingSpaceInSelection = originalSelectedText.substring(originalSelectedText.indexOf(coreText) + coreText.length);

            const formattedText = `${prefix}${coreText}${suffix}`;
            markdownInput.value = `${textBeforeSelection}${leadingSpaceInSelection}${formattedText}${trailingSpaceInSelection}${textAfterSelection}`;
            
            // Select the formatted core text
            const newSelectionStart = textBeforeSelection.length + leadingSpaceInSelection.length + prefix.length;
            const newSelectionEnd = newSelectionStart + coreText.length;
            markdownInput.setSelectionRange(newSelectionStart, newSelectionEnd);
        } else {
            // No text selected, or selection is only whitespace: insert with placeholder
            const textToInsert = `${prefix}${placeholder}${suffix}`;
            markdownInput.value = `${textBeforeSelection}${textToInsert}${textAfterSelection}`;
            
            const placeholderStart = start + prefix.length;
            const placeholderEnd = placeholderStart + placeholder.length;
            markdownInput.setSelectionRange(placeholderStart, placeholderEnd);
        }
        
        markdownInput.focus();
        updatePreview(); // Update preview immediately after applying format
    }

    // Event listeners for toolbar buttons
    toolbarBold?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("**", "**", "bold text"); });
    toolbarItalic?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("*", "*", "italic text"); });
    toolbarH1?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n# ", "\n", "Heading 1"); });
    toolbarH2?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n## ", "\n", "Heading 2"); });
    toolbarH3?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n### ", "\n", "Heading 3"); });
    toolbarUL?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n- ", "", "List item"); });
    toolbarOL?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n1. ", "", "List item"); });
    toolbarLink?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("[", "](url)", "Link text"); });
    toolbarImage?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("![", "](alt text)", "Image"); });
    toolbarCodeBlock?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n```\n", "\n```\n", "code"); });
    toolbarBlockquote?.addEventListener("click", (event) => { event.preventDefault(); applyMarkdownFormatting("\n> ", "", "Quoted text"); });
    toolbarHelp?.addEventListener("click", (event) => {
        event.preventDefault();
        window.open('https://guides.github.com/features/mastering-markdown/', '_blank');
    });

    if (
        form instanceof HTMLFormElement &&
        saveButton instanceof HTMLButtonElement &&
        feedbackMessage instanceof HTMLElement
    ) {
        form.addEventListener("submit", async (event) => {
            event.preventDefault();
            saveButton.disabled = true;
            saveButton.textContent = "Saving...";
            feedbackMessage.textContent = "";

            const formData = new FormData(form);
            const updatedFrontmatter = JSON.parse(
                JSON.stringify(initialFrontmatter || {}),
            );
            const updatedBody = formData.get("body"); // FormDataEntryValue | null

            for (const [key] of formData.entries()) {
                // Iterate only keys, get value from form.elements or formData
                if (key !== "body") {
                    const formElement = form.elements.namedItem(key);
                    const formValue = formData.get(key); // FormDataEntryValue

                    if (
                        formElement instanceof HTMLInputElement &&
                        formElement.type === "checkbox"
                    ) {
                        updatedFrontmatter[key] = formElement.checked;
                    } else if (typeof initialFrontmatter[key] === "number") {
                        updatedFrontmatter[key] =
                            typeof formValue === "string"
                                ? parseFloat(formValue) || 0
                                : 0;
                    } else if (
                        key === "tags" &&
                        typeof formValue === "string"
                    ) {
                        updatedFrontmatter[key] = formValue
                            .split(",")
                            .map((tag) => tag.trim())
                            .filter((tag) => tag !== "");
                    } else {
                        // For other types (string, date string from ISO), assign the string value from FormData
                        updatedFrontmatter[key] =
                            typeof formValue === "string" ? formValue : "";
                    }
                }
            }

            if (
                contentType === "draft" &&
                updatedFrontmatter.hasOwnProperty("slug")
            ) {
                updatedFrontmatter.slug = slugToSave;
            }
            if (contentType === "published") {
                updatedFrontmatter.slug = slugToSave;
                delete updatedFrontmatter.draft;
            }

            const endpoint =
                contentType === "published"
                    ? `/api/admin/content/save-published-post`
                    : `/api/admin/content/save-draft`;

            try {
                const response = await fetch(endpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        slug: slugToSave,
                        frontmatter: updatedFrontmatter,
                        body:
                            typeof updatedBody === "string" ? updatedBody : "", // Ensure body is string
                    }),
                });
                const resultText = await response.text();
                let result;
                try {
                    result = JSON.parse(resultText);
                } catch (e) {
                    if (!response.ok)
                        throw new Error(
                            resultText ||
                                "Failed to save. Server returned non-JSON response.",
                        );
                    result = {
                        message:
                            resultText ||
                            "Saved successfully (non-JSON response).",
                    };
                }
                if (response.ok) {
                    feedbackMessage.textContent =
                        result.message || "Saved successfully!";
                    feedbackMessage.className = "text-green-500";
                    setTimeout(() => {
                        window.location.href =
                            contentType === "published"
                                ? `/admin/content?view=published`
                                : "/admin/content?view=drafts";
                    }, 1500);
                } else {
                    throw new Error(result.message || "Failed to save.");
                }
            } catch (err) {
                feedbackMessage.textContent = `Error: ${err.message}`;
            }
        });
    }

    if (
        aiSuggestButton instanceof HTMLButtonElement &&
        aiSuggestionsArea instanceof HTMLElement &&
        aiSuggestionsText instanceof HTMLElement &&
        form instanceof HTMLFormElement
    ) {
        aiSuggestButton.addEventListener("click", async (event) => {
            event.preventDefault();
            aiSuggestButton.disabled = true;
            aiSuggestButton.textContent = "Getting suggestions...";
            aiSuggestionsArea.classList.remove("hidden");
            aiSuggestionsText.textContent = "";

            const formData = new FormData(form);
            const updatedFrontmatter = JSON.parse(
                JSON.stringify(initialFrontmatter || {}),
            );
            const updatedBody = formData.get("body"); // FormDataEntryValue | null

            for (const [key] of formData.entries()) {
                // Iterate only keys, get value from form.elements or formData
                if (key !== "body") {
                    const formElement = form.elements.namedItem(key);
                    const formValue = formData.get(key); // FormDataEntryValue

                    if (
                        formElement instanceof HTMLInputElement &&
                        formElement.type === "checkbox"
                    ) {
                        updatedFrontmatter[key] = formElement.checked;
                    } else if (typeof initialFrontmatter[key] === "number") {
                        updatedFrontmatter[key] =
                            typeof formValue === "string"
                                ? parseFloat(formValue) || 0
                                : 0;
                    } else if (
                        key === "tags" &&
                        typeof formValue === "string"
                    ) {
                        updatedFrontmatter[key] = formValue
                            .split(",")
                            .map((tag) => tag.trim())
                            .filter((tag) => tag !== "");
                    } else {
                        // For other types (string, date string from ISO), assign the string value from FormData
                        updatedFrontmatter[key] =
                            typeof formValue === "string" ? formValue : "";
                    }
                }
            }

            if (
                contentType === "draft" &&
                updatedFrontmatter.hasOwnProperty("slug")
            ) {
                updatedFrontmatter.slug = slugToSave;
            }
            if (contentType === "published") {
                updatedFrontmatter.slug = slugToSave;
                delete updatedFrontmatter.draft;
            }

            const endpoint =
                contentType === "published"
                    ? `/api/admin/content/save-published-post`
                    : `/api/admin/content/save-draft`;

            try {
                const response = await fetch(endpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        slug: slugToSave,
                        frontmatter: updatedFrontmatter,
                        body:
                            typeof updatedBody === "string" ? updatedBody : "", // Ensure body is string
                    }),
                });
                const resultText = await response.text();
                let result;
                try {
                    result = JSON.parse(resultText);
                } catch (e) {
                    if (!response.ok)
                        throw new Error(
                            resultText ||
                                "Failed to save. Server returned non-JSON response.",
                        );
                    result = {
                        message:
                            resultText ||
                            "Saved successfully (non-JSON response).",
                    };
                }
                if (response.ok) {
                    aiSuggestionsText.textContent =
                        result.message || "Suggestions received!";
                    aiSuggestionsText.className = "text-green-500";
                } else {
                    throw new Error(
                        result.message || "Failed to get suggestions.",
                    );
                }
            } catch (err) {
                aiSuggestionsText.textContent = `Error: ${err.message}`;
            } finally {
                aiSuggestButton.disabled = false;
                aiSuggestButton.textContent = "Get AI Suggestions";
            }
        });
    }

    // Function to extract image URLs from markdown
    function extractImageUrls(markdown) {
        const imageUrls = [];
        const imageRegex = /!\[.*?\]\((.*?)\)/g;
        let match;
        while ((match = imageRegex.exec(markdown)) !== null) {
            if (match[1]) {
                imageUrls.push(match[1]);
            }
        }
        return imageUrls;
    }

    // Function to update the image list UI
    function updateImageListUI(imageUrls) {
        if (!imageList) return;

        imageList.innerHTML = ''; // Clear current list

        if (imageUrls.length === 0) {
            imageListArea?.classList.add('hidden');
            return;
        }

        imageListArea?.classList.remove('hidden');
        imageUrls.forEach(url => {
            const listItem = document.createElement('li');
            listItem.classList.add('mb-2', 'flex', 'items-center', 'space-x-2', 'cursor-pointer', 'hover:bg-theme-bg-alt', 'p-1', 'rounded');
            listItem.dataset.imageUrl = url; // Store URL on the element
            
            // Add a small image preview if possible
            const img = document.createElement('img');
            img.src = url;
            img.classList.add('w-10', 'h-10', 'object-cover', 'rounded');
            img.onerror = () => { 
                // Hide image if it fails to load
                img.style.display = 'none'; 
                // Optionally, add a placeholder icon/text
                const placeholder = document.createElement('span');
                placeholder.textContent = '[Image]';
                placeholder.classList.add('text-theme-text-muted');
                listItem.prepend(placeholder);
            };
            listItem.appendChild(img);

            const urlSpan = document.createElement('span');
            urlSpan.textContent = url;
            urlSpan.classList.add('text-sm', 'text-theme-text');
            listItem.appendChild(urlSpan);
            
            imageList.appendChild(listItem);
        });
    }

    // Variable to temporarily store the old image URL during replacement
    let replacingImageUrl = null;

    // --- Event Listeners ---

    // Handle click on image list items for replacement
    if (imageList) {
        imageList.addEventListener('click', (event) => {
            const target = event.target;
            const listItem = target.closest('li');
            if (listItem && listItem.dataset.imageUrl && imageUploadInput) {
                replacingImageUrl = listItem.dataset.imageUrl;
                console.log('Replacing image:', replacingImageUrl);
                // Trigger file input programmatically
                imageUploadInput.click();
            }
        });
    }

    // Update preview and image list on input
    if (markdownInput) {
        markdownInput.addEventListener("input", debounce(() => {
            updatePreview();
            const imageUrls = extractImageUrls(markdownInput.value);
            updateImageListUI(imageUrls);
        }, 250)); // Debounce for 250ms
    }

    // Trigger file input when image button is clicked
    if (toolbarImage && imageUploadInput) {
        toolbarImage.addEventListener('click', () => {
            imageUploadInput.click();
        });
    }

    // Placeholder for file input change (upload handling - next subtask)
    if (imageUploadInput) {
        imageUploadInput.addEventListener('change', async (event) => {
            console.log('File selected for upload:', event.target.files[0]);
            const file = event.target.files?.[0];

            if (!file) {
                return; // No file selected
            }

            const formData = new FormData();
            formData.append('image', file);

            try {
                const response = await fetch('/api/admin/upload-image', {
                    method: 'POST',
                    headers: {
                        // This is often set automatically by the browser for FormData,
                        // but we include it explicitly to see if it resolves the server-side error.
                        // Note: The browser will still add the 'boundary' parameter.
                        'Content-Type': 'multipart/form-data',
                    },
                    body: formData,
                });

                const result = await response.json();

                if (response.ok) {
                    console.log('Upload successful:', result.url);
                    // Insert markdown into the editor
                    const imageUrl = result.url;
                    const markdownTag = `![alt text](${imageUrl})`; // TODO: Allow user to input alt text

                    if (markdownInput) {
                        const start = markdownInput.selectionStart;
                        const end = markdownInput.selectionEnd;
                        const currentValue = markdownInput.value;

                        if (replacingImageUrl) {
                            // Find the old markdown tag and replace it
                            const oldMarkdownTagRegex = new RegExp(`!\[.*?\]\\(${replacingImageUrl.replace(/[.*+?^${}()|\[\]\\]/g, '\\$&')}\\)`, 'g');
                            markdownInput.value = currentValue.replace(oldMarkdownTagRegex, markdownTag);
                        } else {
                            // Insert at cursor for new images
                            markdownInput.value = currentValue.substring(0, start) +
                                                markdownTag +
                                                currentValue.substring(end);

                            // Move cursor after the inserted tag only for new images
                            markdownInput.selectionStart = markdownInput.selectionEnd = start + markdownTag.length;
                        }

                        // Trigger input event to update preview and image list
                        markdownInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }

                } else {
                    console.error('Upload failed:', result.error);
                    // Display error message to the user (e.g., in the feedbackMessage area)
                    if (feedbackMessage) {
                        feedbackMessage.textContent = `Upload failed: ${result.error}`;
                        feedbackMessage.style.color = 'red';
                    }
                }

            } catch (error) {
                console.error('Error during upload fetch:', error);
                 if (feedbackMessage) {
                    feedbackMessage.textContent = `Upload failed: ${error.message}`;
                    feedbackMessage.style.color = 'red';
                }
            }
             // Clear the file input so the same file can be selected again
            event.target.value = '';

            // Reset replacingImageUrl after handling the upload
            replacingImageUrl = null;
        });
    }

    // Initial preview and image list update on page load
    updatePreview();
    if (markdownInput) {
        const imageUrls = extractImageUrls(markdownInput.value);
        updateImageListUI(imageUrls);
    }
</script>
